Title:	DB maintenance job
Stat:	open
Disp:	
Prio:	high
Cats:	dev
Reqtrs:	
AssdTo:	stuart

2007-02-01 00:00:00 stuart@friix.com
  database -- write maintenance scripts to check for things that are hard
  to write contraints for: do all senses have at least one gloss?  do all
  (jmdict) entries have at least one sense and reading?, Are
  rdng,kanj,sens,gloss ord numbers consecutive?
  Does each set of src/seq entries have at most one active approved entry?

  It may be useful to duplicate some of the input checking requested in
  IS-168 on database entries in case any sneak in by other routes.

  Need a cron job to delete D and R entries after some period of time.

2010-06-16 22:08:00 stuart
  JMdictDB being used for live updates by Jim Breen now, which means
  this issue is now much higher priority.

2010-07-23 12:41:00 stuart
  Here are some queries that can be used:

  -----------------------------------------------------------------------
  -- Although unapproved entries may have or not have
  -- a 'dfrm' value, approved entries should never have
  -- a 'dfrm' value.
  SELECT e.id
  FROM entr e
  WHERE NOT e.unap AND e.dfrm IS NOT NULL;
  -----------------------------------------------------------------------
  -- More that one "A" (approved and active) entry is a seqset.
  SELECT src, seq
  FROM entr e
  WHERE (NOT dfrm OR unap) AND stat=2
  GROUP BY src, seq
  HAVING count(*)>1;
  -----------------------------------------------------------------------  
  -- Mixed corpora or seq# in editset.
  SELECT e1.id, e2.id
  FROM entr e1
  JOIN entr e2 ON e2.dfrm=e1.id
  WHERE e1.src!=e2.src OR e1.seq!=e2.seq;
  -----------------------------------------------------------------------
  -- Look for dfrm cycles.
  WITH RECURSIVE wt (id, dfrm, depth, path, cycle) AS (
        SELECT e.id, e.dfrm, 1, ARRAY[e.id], false
        FROM entr e
          UNION ALL
        SELECT e.id, e.dfrm, wt.depth+1, path||e.id, e.id=ANY(path)
        FROM entr e, wt
        WHERE e.id = wt.dfrm AND NOT cycle)
  SELECT * FROM wt WHERE cycle;
  -----------------------------------------------------------------------
  -- Find "deleted" entries due for expungement.  Change
  -- the "e.stat=4" to "e.stat=6" for "rejected" entries.
  SELECT e.id, MAX(h.dt)
  FROM entr e
  JOIN hist h ON h.entr=e.id
  WHERE e.stat=4 AND NOT e.unap
      -- Exclude entries that other entries point to;
      -- if not the other entries will also be deleted.
    AND NOT EXISTS (SELECT 1 FROM entr WHERE dfrm=e.id)
  GROUP BY e.id
  HAVING MAX(dt)<(CURRENT_TIMESTAMP AT TIME ZONE 'utc'-'30 days'::INTERVAL);
  -----------------------------------------------------------------------
