Title:	Multiple rdng/kanj freq tags displayed
Stat:	closed
Disp:	done
Prio:	high
Cats:	bug
Reqtrs:	
AssdTo:	stuart@friix.com

2007-02-26 00:00:00 stuart@friix.com
  If a reading (or kanji) has a the same FoU tag paired with two 
  (or more) kanji (or readings), the tag will be shown twice (or 
  more) on the reading (or kanji).  Example: seq 1579780 (主人).

2008-05-07 23:09:00 stuart@friix.com
  Freq tags for display were generated by iterating the entry's 
  freq list, and getting the kw string for each non-null kanj 
  (for kfreq) ot rdng (for rfreq) value.

  For seq 1579780, there are one kanji and two readings with a
  "spec1" tag.  This results in freq table records:

   entr | rdng | kanj | kw | value |  kw
  ------+------+------+----+-------+------
    546 |    1 |    1 |  4 |     1 | spec
    546 |    4 |    1 |  4 |     1 | spec

  Iterating the kanj values results in the double spec1's in
  the kanji display.

  Fixed by filtering out duplicate values after generating the 
  freq list.  There are three places this needed to be done:
	tal.py (function TALfreqs())
	fmt.py (functions kanj() and rdng())
	fmtxml.py (function freqs())
  The dup filtering code was moved from jmxml.py (unique() and 
  remove_dups()) to jdb.py (unique() and rmdups()).  We use that
  function (rather than the more conventional use of Python's 
  "set" datatype, because we want to preserve the order of the
  items.)

2012-11-16 08:13:00 stuart
  For reference the following page compares the performance of a
  number of methods to remove duplicates from a list (aka "deduplicate",
  "uniquifying", "uniqify"), both order-preserving and not:
    http://www.peterbe.com/plog/uniqifiers-benchmark
  The fastest order-preverving one was:
    def f5(seq, idfun=None): 
       # order preserving
       if idfun is None:
           def idfun(x): return x
       seen = {}
       result = []
       for item in seq:
           marker = idfun(item)
           # in old Python versions:
           # if seen.has_key(marker)
           # but in new ones:
           if marker in seen: continue
           seen[marker] = 1
           result.append(item)
       return result
  jdb.rmdups() seems to take about the same approach as the above
  and given the very short lists that is its typical use case in
  jmdictdb, the existing code does not seem to need any changes 
  based on that blog post.
  There is also a stackoverflow post addressing the same issue:
    http://stackoverflow.com/questions/480214/how-do-you-remove-duplicates-from-a-list-in-python-whilst-preserving-order
  and message/thread on python-ideas list:
    http://mail.python.org/pipermail/python-ideas/2012-November/017893.html
  and:
    http://code.activestate.com/recipes/52560-remove-duplicates-from-a-sequence/
