Title:	xrefs disappearing from database
Stat:   closed
Disp:	done
Prio:	crit
Cats:	dev
Reqtrs:	
AssdTo:	stuart

2010-06-02 20:37:00 stuart 
  jwb reports via email that cross references are 
  disappearing from database.  Was able to reproduce
  by editing an entry that was the target of another
  entry's xref... the edited entry no longer has a
  reverse xref to the other entry, and when it is 
  approved, and it's parent deleted, the deletion 
  takes the other entry's xref with it.

  One example he gave involved entry seq 1982880 which
  has two xrefs to senses 1 and 2 of seq 1982890.
  Editing the latter, and approving it caused the xrefs
  on the former to disappear.

2010-06-02 21:18:00 stuart
  One problem appears to be the change made to
  jdb.add_entr() in hg rev f5aad65a2c47-2010-04-30
  which disabled writing rev xrefs to database:

  -	    for x in getattr (s, '_xrer',  []): dbinsert (cur, "xrer",  ['entr','sens','xref','typ','xentr','xsens','rdng','kanj','notes'], x)
  +	    # Don't create xrefs for xrer items -- these mirror the xrefs on the xrer targets.
  +         #for x in getattr (s, '_xrer',  []): dbinsert (cur, "xref",  ['entr','sens','xref','typ','xentr','xsens','rdng','kanj','notes'], x)

  We cannot simply fail to add these reverse xrefs because
  these are what will become the current "real" xrefs when
  the parent entry is deleted and this entry becomes the
  active entry.  Reenabled the commented out line.

  Second problem is the reverse xrefs are getting lost in
  web/python/edconf.cgi.  There is a no JEL syntax for reverse
  xrefs so they are not represented in the entry received 
  from edform.py.  Nor does edconf.conf copy them from the 
  parent entry.

  Ideally (I realize too late), rev xrefs would be represented 
  in edform somehow and be as editable as forward xrefs are.
  I erroneously perceived them as a sort of shadow xref
  whose real existence (and place for editing) was on the 
  main entry, but that is not really right.  A change in 
  an xref target (change to a sense's meaning that invalidates
  an xref that points to it), or the reordering of senses 
  would require the modification of the "other entry's" xref
  and that should be doable when making the change that 
  necessitates the xref change -- when editing the target.

  As an iterim fix, will treat them like freq items for 
  non-editor -- they will not be editable: edconf and 
  edsubmit will both copy them from from the parent as
  best they can, by sense number.  If senses are reordered
  or new senses inserted, then the referencing entry will 
  need to be edited afterwards to make any corrections. 

2010-06-03 13:40:00 stuart
  Additional problems found:
  
  1. jdb.set_keys() was resetting attributes 'entr' and 'sens' 
  in the ._xrer list items.  Should reset 'xentr' and 'xsens'. 
  
  2. Attempt to add entries with rev xrefs failing on a pk
  violation because the xref table pk is (entr, sens, xref)
  and all three will be the same for cloned rev xrefs.
  Changed pk in pg/mktables.sqk to (entr,sens,xref,xentr,xsens). 
  To change the xref table in-suto:
    ALTER TABLE xref DROP CONSTRAINT xref_pkey;
    ALTER TABLE xref ADD  CONSTRAINT xref_pkey PRIMARY KEY (entr,sens,xref,xentr,xsens);

  After these changes, xrefs are no longer getting "lost" 
  but now the problem is that the rev xrefs from edited
  entries appear in the (approved and unchanged) referencing 
  entry.  E.g., after creating an unapproved edit of 1982890,
  1982880 now shows 4 xrefs: two to the approved parent
  entry, and two (seemingly identical except for the "&e="
  value in the link) xrefs pointing to the new, edited, 
  unapproved entry.  

2010-06-04 13:35:00 stuart
  (Partial?) fix for the multiple xref displasy problem
  noted above.  Created new function jmcgi.add_filtered_xrefs()
  that can be called on an entry before passing that entry 
  to entr.tal for display.  This function will made copies
  of the xref and reverse xref lists in the entries' senses'
  .xref and .xrer attributes as nerw attributes ,XREF and
  .XRER.  These copies be identical to their source lists
  except some xrefs may be removed.

  Specifically it removes any xref (or rev xref) that points
  to an unapproved entry *if* the current entry is approved.
  It also unconditionally removes refs that point to deleted
  (stat=D) or rejected (stat=R) entries.

  Although possibly confusing, it does not remove refs to
  unapproved entries if the current entry is also unapproved.
  This can be rationalized by considering that a submitter or
  editor should be informed when there are pending changes on
  a reference target because that may affect decisions about 
  the reference that this entry has.  It might be a desirable
  to-do to visually make clearer that the refs are to different
  versions of the same entry.

  In web/cgi/entr.py we now call jmcgi.add_filtered_xrefs()
  before generating the web page.  We don't currently call
  it in web/cgi/edconf.py on the grounds that this must
  have just been edited (although we do copy ._xref and
  ._xrer unmodified to .XREF and .XRER because that's what's
  needed by the TAL template) but failing to call it means
  that refs to deleted and rejected entries will show up so
  maybe we should call it. 

  In python/lib/tmpl/entr.py and python/lib/tmpl/enconf.py 
  we changed references to raw sense reference lists s/_xref
  and s/_xrer to the filtered lists s/XREF and s/XRER.
  In theory we could have left edconf.tal alone since edconf.py
  does not modify the ref lists but a) that might change in
  future as noted above, and b) edconf.tal and entr.tal are
  nearly identical and we don't want to introduce any 
  unecessary differences.

2010-06-16 22:56:00 stuart
  Fixed in changesets b8a41eef87cc-2010-06-03, 
  8850731ccc08-2010-06-04 and 2a2c0c9a193c-2010-06-04.
