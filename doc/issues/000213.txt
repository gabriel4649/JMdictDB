Title:	Enforce only one A entry in database
Stat:	open
Disp:	
Prio:	med
Cats:	dev
Reqtrs:	
AssdTo:	stuart

2012-04-26 21:56:00 stuart
  Currently, the jmdictdb application code has expects
  there to be only one "active" (A) entry in any group of
  entries with the same seq#.  However, since an A entry
  is defined as an entry having unap=False and stat=2, it
  is possible to set these values on multiple entries thus
  violating the "only one" contraint.
  I would like to enforce the "only one A" contraint at
  the database level.
  This would also allows xrefs to refer to their target
  by seq# only since the db would now guarantee that their
  was only one such (active) target.

2012-04-26 22:02:00 stuart
  The following was my first idea but it doesn't work.
  Add a table, call it "actv" defined like:

  CREATE UNIQUE INDEX ON entr(id,seq);
  CREATE TABLE actv (
    seq BIGINT PRIMARY KEY,
    entr INT NOT NULL UNIQUE,
    FOREIGN KEY (entr,seq) REFERENCES entr(id,seq));

  This table will only allow one entry to be associated 
  with one seq number and allows disallows multiple rows
  with the same seq# and thus can define *the* single 
  approved entry in a group of common seq# entries..

  But it is no good -- we can can have arbitrary number
  of D and R stat'd entries either approved or unapproved,
  in a seq# set and the above provides no assurance that a 
  row in 'actv' points to a stat=2,unap=F entr. 

  The ability to reference xref targets by seq# is also 
  iffy -- how to create xrefs when there isn't an active
  entry yet: e.g. creating a new entry with xref to other 
  new entry, or creating an xref to newly addded (but not
  yet approved) sense in an existing entry?

  Another question (this also present in current code): is 
  the "one active entry" constraint really on just the same 
  seq# set?  What about an edit set when some of the edits 
  have changed the seq#?  (see IS-143).

2012-04-28 09:45:00 stuart
 I think we can an use a unique partial index to enforce only
 one active entry:
    CREATE UNIQUE INDEX ON entr(seq,stat,unap) WHERE stat=2 AND NOT unap;
 but this does not provide a way for xrefs to reference by
 seq# since one apperantly can't create an FK that references 
 a partial unique index.

2012-05-03 15:43:00 stuart
 Backout the above index (removed patches/007_01.sql and commented
 out the line tha creates the index in pg/mktables.sql.  

 Problem is that with the index in place, I am unable to submit
 "approved" entries; get a key violation on that index. 

2012-05-29 18:25:00 stuart
 Change I thought I backed out above was not... I forgot to do a
 "make" in pg/ with the result that pg/mkindex.sql has still been
 creating the problem index, "entr_active", on table "entr".
 Hence any database created between then and now will reject the
 submission of edited entries. 
