%{
#######################################################################
#   This file is part of JMdictDB. 
#   Copyright (c) 2006,2007 Stuart McGraw 
# 
#   JMdictDB is free software; you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published 
#   by the Free Software Foundation; either version 2 of the License, 
#   or (at your option) any later version.
# 
#   JMdictDB is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
# 
#   You should have received a copy of the GNU General Public License
#   along with JMdictDB; if not, write to the Free Software Foundation,
#   51 Franklin Street, Fifth Floor, Boston, MA  02110#1301, USA
#######################################################################

#ed::@VERSION = (substr('$Revision$',11,-2), \
#	    substr('$Date$',7,-11));

use strict; #use warnings; 
BEGIN {push (@INC, "../perl/lib");}
use utf8; use jmdict; 

use kwstatic;
# Make "nokanji" a psuedo-keyword...
$::KW = $kwstatic::Kwds;
$::KW->{RESTR} = {'nokanji'=>{id=>'nokanji', kw=>'nokanji'}};

use Dumpvalue;		# For debugging.
$::D = new Dumpvalue;

%}
%token KTEXT RTEXT BRKTL BRKTR COMMA COLON SEMI EQL SNUM TEXT GTEXT 
%%

entr	: preentr
				{ dbgprt (1, "preentr -> entr");
				  my ($e) = $_[1];
				    # Set record numbers in child lists because we will
				    # will use those numbers in mk_restrs().
				  setkeys ($e, 1); 
				    # The reading and sense restrictions here are simple
				    # lists of text strings that give the allowed readings
				    # or kanji.  mk_restrs() converts those to the canonical
				    # format which uses the index number of the disallowed 
				    # readings or kanji. 
				  if (!mk_restrs ("_RESTR", $e->{_rdng}, "rdng", $e->{_kanj}, "kanj")) {
				    $_[0]->YYError(); }
				  if (!mk_restrs ("_STAGK", $e->{_sens}, "sens", $e->{_kanj}, "kanj")) {
				    $_[0]->YYError(); }
				  if (!mk_restrs ("_STAGR", $e->{_sens}, "sens", $e->{_rdng}, "rdng")) {
				    $_[0]->YYError(); }
				    # Confirm the validity of all the xrefs.
				  #rslv_xrefs (); 
				  $e; }
				  ;
preentr
	: rdngsect senses
				{ dbgprt (1, "rdngsect senses -> preentr");
				  {_rdng=>$_[1], _sens=>$_[2]}; }
	| kanjsect rdngsect senses
				{ dbgprt (1, "kanjsect rdngsect senses -> preentr");
				  {_kanj=>$_[1], _rdng=>$_[2], _sens=>$_[3]}; }
				  ;
kanjsect
	: kanjitem
				{ dbgprt (1, "kanjitem -> kanjsect"); 
				  [$_[1]]; }
	| kanjsect SEMI kanjitem
				{ dbgprt (1, "kanjsect SEMI kanjitem -> kanjsect");
				  push (@{$_[1]}, $_[3]);
				  $_[1]; }
				;
kanjitem
	: KTEXT 
				{ dbgprt (1, "KTEXT -> kanjitem"); 
				  {txt=>$_[1]}; }
	| KTEXT taglists
				{ dbgprt (1, "KTEXT taglists -> kanjitem"); 
				  my ($kanj) = {txt=>$_[1]};
				  if (!bld_kanj ($kanj, $_[2])) { $_[0]->YYError(); }
				  $kanj; }
				  ;
rdngsect
	: rdngitem
				{ dbgprt (1, "rdngitem -> rdngsect"); 
				  [$_[1]]; }
	| rdngsect SEMI rdngitem
				{ dbgprt (1, "rdngsect SEMI rdngitem -> rdngsect"); 
				  push (@{$_[1]}, $_[3]);
				  $_[1]; }
				  ;				
rdngitem
	: RTEXT
				{ dbgprt (1, "RTEXT -> rdngitem"); 
				  {txt=>$_[1]}; }
	| RTEXT taglists
				{ dbgprt (1, "RTEXT taglists -> rdngitem");
				  my ($rdng) = {txt=>$_[1]};
				  if (!bld_rdng ($rdng, $_[2])) { $_[0]->YYError(); }
				  $rdng; }
				  ;
senses
	: sense
				{ dbgprt (1, "sense -> senses"); 
				  [$_[1]]; }
	| senses sense
				{ dbgprt (1, "senses sense -> senses"); 
				  push (@{$_[1]}, $_[2]);
				  $_[1]; }
				  ;
sense
	: SNUM {_setlexstate(2)} sensitems
				{ dbgprt (1, "SNUM sensitems -> sense");
				  my ($sens) = {};
				  if (!bld_sens ($sens, $_[3])) { $_[0]->YYError(); }
				  $sens; }
				  ;
sensitems
	: sensitem
				{ dbgprt (1, "sensitem -> sensitems"); 
				  $_[1]; }
	| sensitems sensitem
				{ dbgprt (1, "sensitems sensitem -> sensitems"); 
				  push (@{$_[1]}, @{$_[2]});
				  $_[1]; }
				  ;
sensitem
	: glossset
				{ dbgprt (1, "glossset -> sensitem");
				  $_[1]; }
	| taglist
				{ dbgprt (1, "taglist -> sensitem");
				  $_[1]; }
				  ;
glossset
	: GTEXT
				{ dbgprt (1, "GTEXT -> glossset"); 
				  [["gloss", gcleanup ($_[1])]]; }
	| glossset SEMI GTEXT
				{ dbgprt (1, "glossset SEMI GTEXT -> glossset");
				  push (@{$_[1]}, ["gloss", gcleanup ($_[3])]);
				  $_[1]; }
				  ;
taglists
	: taglist
				{ dbgprt (1, "taglist -> taglists");
				  $_[1]; }
	| taglists taglist
				{ dbgprt (1, "taglists taglist -> taglists");
				  push (@{$_[1]}, @{$_[2]}); 
				  $_[1]; }
				  ;
taglist
	: BRKTL {_pushlexstate(1)} tags {_poplexstate()} BRKTR
				{ dbgprt (1, "BRKTL tags BRKTR -> taglist");
				  $_[3]; }
				  ;
tags
	: tagitem
				{ dbgprt (1, "tagitem -> tags"); 
				  [$_[1]]; }
	| tags COMMA tagitem
				{ dbgprt (1, "tags COMMA tagitem -> tags");
				  push (@{$_[1]}, $_[3]);
				  $_[1]; }
				  ;
tagitem
	: TEXT				# Simple keyword tag (including "nokanji").
				{ dbgprt (1, "TEXT -> tagitem");
				  my ($x) = lookup_tag ($_[1]);
				  if ($x == -1) { 
				    error ("Unknown keyword: '$_[1]'");
				    $_[0]->YYError(); } 
				  if ($x == -2) { 
				    error ("Ambiguous keyword: '$_[1]'");
				    $_[0]->YYError(); }
				  $x; }

	| TEXT EQL TEXT			# typ=tag, note=xxx, lsrc=txt, lit=text, expl=text, restr=nokanji
				{ dbgprt (1, "TEXT EQL TEXT -> tagitem"); 
				  return [$_[1],$_[3],1] if ($_[1] eq "note" or $_[1] eq "lit" or $_[1] eq "expl");
				  return [$_[1],$_[3],1] if ($_[1] eq "lsrc");
				  my ($x) = lookup_tag ($_[3], $_[1]);
				  if ($x == -1) {
				    error ("Unknown $_[1] keyword: '$_[3]'");
				    $_[0]->YYError(); }
				  if ($x == -3) { 
				    error ("Unknown keyword type: '$_[1]'");
				    $_[0]->YYError(); }
				  $x; } 

	| TEXT EQL TEXT COLON 		# lsrc=xx: ('xx' is language code.)
				{ dbgprt (1, "TEXT EQL TEXT COLON -> tagitem"); 
				  if ($_[1] ne "lsrc") {
				    error ("Keyword must be \"lsrc\"");
				    $_[0]->YYError (); }
				  my ($la) = $::KW->{LANG}{$_[3]}{id};
				  if (!$la) {
				    error ("Unrecognised language '$_[3]'");
				    $_[0]->YYError (); }
				  ["lsrc", undef, $la]; }

	| TEXT EQL TEXT COLON TEXT	# lsrc=xx:text, lit=xx:text, expl=xx:text
				{ dbgprt (1, "TEXT EQL TEXT COLON TEXT -> tagitem"); 
				  
				  if ($_[1] ne "lsrc" and $_[1] ne "lit" and $_[1] ne "expl") {
				    error ("Keyword not \"lsrc\", \"lit\", or \"expl\"");
				    $_[0]->YYError (); }
				  my ($la) = $::KW->{LANG}{$_[3]}{id};
				  if (!$la) {
				    error ("Unrecognised language '$_[3]'");
				    $_[0]->YYError (); }
				  ["lsrc", $_[5], $la]; }

	| TEXT EQL jitems		# xref=k/r[n1,n2,..], restr=k;k;.. (restr, stagr,stagk)
				{ dbgprt (1, "TEXT EQL jitems -> tagitem"); 
				  if ($_[1] ne "restr" and $_[1] ne "see" and $_[1] ne "ant") {
				    error ("Keyword not \"restr\", \"see\", or \"ant\"");
				    $_[0]->YYError (); }
				    ;
				  if ($_[1] eq "restr") { $_[1] = "RESTR"; }
				  [$_[1], $_[3]]; }
				;
jitems
	: jitem
				{ dbgprt (1, "jitem -> jitems"); 
				  [$_[1]]; }
	| jitems SEMI jitem	
				{ dbgprt (1, "jitems jitem -> jitems");
				  push (@{$_[1]}, $_[3]);
				  $_[1]; }
				  ;
jitem
	: jtext
				{ dbgprt (1, "jtext -> jitem");
				   $_[1]; }
	| jtext slist
				{ dbgprt (1, "jtexts -> jitem");
				  $_[1]->[2] = $_[2];  
				  $_[1]; }
				  ;
jtext	
	: KTEXT
				{ dbgprt (1, "KTEXT -> jtext"); 
				  [$_[1],undef,undef]; }
	| RTEXT
				{ dbgprt (1, "RTEXT -> jtext"); 
				  [undef,$_[1],undef]; }
	| KTEXT SLASH RTEXT
				{ dbgprt (1, "KTEXT SEMI RTEXT-> jtext"); 
				  [$_[1],$_[3],undef]; }
				  ;
slist
	: BRKTL snums BRKTR
				{ dbgprt (1, "BRKTL snums BRKTR -> slist"); 
				  $_[2]; }
				  ;
snums
	: TEXT
				{ dbgprt (1, "TEXT -> snums"); 
				  my $x = int ($_[1]);
				  if ($x<=0 or $x>99) {
				    error ("Invalid sense number '$x', must be between 1 and 99");
				    $_[0]->YYError(); }
				  [$x]; }
	| snums COMMA TEXT
				{ dbgprt (1, "snums COMMA TEXT -> snums"); 
				  my $x = int ($_[3]);
				  if ($x<=0 or $x>99) {
				    error ("Invalid sense number '$x', must be between 1 and 99");
				    $_[0]->YYError(); }
				  push (@{$_[1]}, $x);
				  $_[1]; }
				  ;


%%
    sub resolv_xrefs { my ($dbh, $e) = @_;
	# An xref given by the user is parsed into a 4-item
	# list:
	#    0 -- Xref type per $::KW->{XREF}.
	#    1 -- Kanji text
	#    2 -- Reading text
	#    3 -- Ref to list of integers, each is a sense
	#           number.
	# Any of the last three elements may be undefined
	# although at least one of the kanji and reading
	# elements will be non-undefined.

	my ($s, $x, $xrefs);
	foreach $s (@{$e->{_sens}}) {
	    foreach $x (@{$s->{_XREF}}) {
		$xrefs = resolv_xref ($dbh, $x->[1], $x->[2],
				      $x->[3], $x->[0], 1, 1);
		if (!$s->{_erefs}) { $s->{_erefs} = []; }
		push (@{$s->{_erefs}}, @$xrefs); }
	    delete ($s->{_XREF}); } }

    sub lookup_tag { my ($tag, $typ) = @_;
	# Lookup $tag (given as a string) if the keyword tables
	# and return the kw id number.  If $typ is given (also 
	# a string and usually capitalized), it gives the kw 
	# domain (e.g. FREQ, KINF, etc) and $tag is looked up
	# in that domain.  If not given, $tag is looked for in
	# every domain.
	# For other than FREQ tags the return value is a 2-tuple:
	# the domain and the kw id number.  For FREQ tags, it is
	# a 3-tuple: the domain, the kw id number and the freq
	# value.
	# If the tag is not found, a scalar -1 is returned.

	my ($t, $x, $fval, $tx);
	if ($typ) {
	    $t = uc ($typ);
	    return -3 if (!$::KW->{$t});
	    if ($t eq "FREQ" and ($tag =~ m/^([^0-9]+)(\d+)$/)) {
		$tag = $1; $fval = $2; }
	    $x = $::KW->{$t}{$tag}{id}; }
	else {
	    foreach $tx (keys (%{$::KW})) {
		$t = $tx;
	        $x = $::KW->{$t}{$tag}{id};
	        last if ($x); }
	    #return -2 if # ambiguous.
	    if (!$x and ($tag =~ m/^([^0-9]+)(\d+)$/)) {  
		$x = $::KW->{FREQ}{$1}{id};  $fval = $2; $t = "FREQ"} }
	return -1 if (!$x);
	return [$t, $x, $fval] if ($t eq "FREQ");
	return [$t, $x]; }

    sub bld_sens { my ($sens, $taglist) = @_;
	# Build a sense record.  We are given a list of sense items
	# in @$taglist.  These are not just tags (keyword records) but
	# anything that goes into a sense: glosses, lsource records,
	# stagr/k restrictions, etc.  Each of these items is an n-tuple
	# with the first element being a string that indicates the type
	# of item, and the remaining elements providing the items' data.
	# Our job is to iterate though this list, and put each item 
	# on the appropriate sense list: e.g. all the "gloss" items go 
	# into the list @{$sens->{_gloss}}, all the "POS" keyword items 
	# go on @{$sens->{_pos}}, etc.
 
	my ($s, $t, $typ, $errs, $jitem, $kw);
	foreach $t (@$taglist) {
	    $typ = shift (@$t);		# Get the item type.
	    if ($typ eq "POS" or $typ eq "MISC" or $typ eq "FLD" or $typ eq "DIAL") {
	        append ($sens, "_".lc($typ), {kw=>$t->[0]}); }
	    elsif ($typ eq "RESTR") { 
		# We can't create real @{_stagk} or @{_stagr} lists here because
		# the readings and kanji we are given by the user are allowed ones,
		# but we need to store disallowed ones.  To get the disallowed ones,
		# we need access to all the readings/kanji for this entry and we 
		# don't have that here.  So we do what checking we can. and save 
		# the texts as given, and will fix later after the full entry is 
		# built and we have access to the entry's readings and kanji.
		foreach $jitem (@{$t->[0]}) {
		    if (($jitem->[0] and $jitem->[1]) or 
			     (!$jitem->[0] and !$jitem->[1]) or $jitem->[3]) { 
			error ("Sense restrictions must have a reading or kanji (but not both): "
			       . fmt_jitem (@$jitem));
			$errs++; }
		    if ($jitem->[0]) { append ($sens, "_STAGK", $jitem->[0]); }
		    if ($jitem->[1]) { append ($sens, "_STAGR", $jitem->[1]); } } }
	    elsif ($typ eq "lsrc")  { append ($sens, "_lsrc",  {txt=>$t->[0], lang=>($t->[1] || 1)}); }
	    elsif ($typ eq "gloss") { append ($sens, "_gloss", {txt=>$t->[0]}); }
	    elsif ($typ eq "lit")   { append ($sens, "_gloss", {txt=>$t->[0], lang=>($t->[1] || 1), ginf=>$KWGINF_lit}); }
	    elsif ($typ eq "expl")  { append ($sens, "_gloss", {txt=>$t->[0], lang=>($t->[1] || 1), ginf=>$KWGINF_expl}); }
	    elsif ($typ eq "note")  { 
		if ($sens->{notes}) { error ("Only one sense note allowed"); $errs++ }
		$sens->{notes} = $t->[0]; }
	    elsif ($typ eq "see" or $typ eq "ant") { 
		foreach $jitem (@{$t->[0]}) {
		    $kw = $::KW->{XREF}{$typ}{id};
		    die "Unable to find xref type '$typ' in KW table!" if (!$kw);
		    append ($sens, "_XREF", [$kw, @$jitem]); } }
	    else { error ("Cannot use '$typ' tag in a sense"); $errs++; } }
	return $errs ? undef : $sens; }

    sub bld_rdng { my ($r, $taglist) = @_;
	my ($typ, $t, $jitem, $errs, $nokanj);
	foreach $t (@$taglist) {
	    $typ = shift (@$t);
	    if ($typ eq "RINF") { append ($r, "_rinf", {kw=>$t->[0]}); }
	    elsif ($typ eq "FREQ") { append ($r, "_rfreq", {kw=>$t->[0], value=>$t->[1]}); }
	    elsif ($typ eq "RESTR") {
		# We can't generate real restr records here because the real
		# records are the disallowed kanji.  We have the allowed
		# kanji here and need the set of all kanji in order to get
		# the disallowed set, and we don't have that now.  So we 
		# just save the allowed kanji as given, and will convert it
		# after the full entry is build and we have all the info we
		# need.
		if ($t->[0] eq "nokanji") { 
		    $nokanj = 1; 
		    $r->{_NOKANJI} = 1;
		    next; }
		foreach $jitem (@{$t->[0]}) {
		    if (!$jitem->[0] or $jitem->[1] or $jitem->[3]) { 
			error ("Reading restrictions must be kanji only: " . fmt_jitem (@$jitem));
			$errs++; }
		    append ($r, "_RESTR", $jitem->[0]); }
		if ($r->{_RESTR} and $nokanj) { 
		    error ("Can't use both kanji and 'nokanji' in 'restr' tags");
		    $errs++; } }
	    else { error ("Cannot use '$typ' tag in a reading"); $errs++; } }
	return $errs ? undef : $r; }

    sub bld_kanj { my ($k, $taglist) = @_;
	my ($typ, $x, $t);
	foreach $t (@$taglist) {
	    $typ = shift (@$t);
	    if ($typ eq "KINF") { append ($k, "_kinf", {kw=>$t->[0]}); }
	    elsif ($typ eq "FREQ") { append ($k, "_kfreq", {kw=>$t->[0], value=>$t->[1]}); }
	    else { error ("Cannot use $typ tag with a kanji"); return undef; } }
	return $k; }

    sub mk_restrs { my ($listkey, $rdngs, $rdngkey, $kanj, $kanjkey, $kmap) = @_;
	# Note: mk_restrs() are used for all three
	# types of restriction info: restr, stagr, stagk.  However to
	# simplify things, the comments and variable names assume use
	# with reading restrictions (restr).  
	#
	# What we do is take a list of restr text items received from
	# a user which list the kanji (a subset of all the kanji for
	# the entry) that are valid with this reading, and turn it 
	# into a list of restr records that identify the kanji that
	# are *invalid* with this reading.  The restr records identify
	# kanji by id number rather than text.
	#
	# $listkey -- Name of the key used to get the list of text
	#    restr items from $rdngs.  These are the text strings
	#    provided by the user.  Should be "_RESTR", "_STAGR", 
	#    or "_STAGK".
	# @$rdngs -- Lists of rdng or sens records depending on whether
	#    we're doing restr or stagr/stagk restrictions.
	# $rdngkey -- Either "rdng" or "sens" depending on whether we're
	#    doing restr or  stagr/stagk restrictions.
	# @$kanj -- List of the entry's kanji or reading records 
	#    depending on whether we are doing restr/stagk or stagr
	#    restrictions.
	# $kanjkey -- Either "kanj" or "rdng" depending on whether we're
	#    doing restr/stagk or stagr restrictions.
	# %$kmap -- (Optional)  A hash of @$kanj keyed by the text strings.
	#    If not given it will be automatically generated, but caller
	#    can supply it to prevent it from being recalculated multiple
	#    times.  [NB: we should cache after generation so caller need
	#    not worry about it at all.]

	my ($r, @nomatch, $restrtxt, %xmap, @disallowed, $nokanj, $errs);
	for $r (@$rdngs) {

	      # Get the list of restr text strings and nokanji flag and
	      # delete them from the rdng object since they aren't part
	      # of the standard api.
	    $restrtxt = $r->{$listkey};
	    delete $r->{$listkey}; 
	    $nokanj = $r->{_NOKANJI};
	    delete $r->{_NOKANJI};

	      # Continue with next reading if nothing to be done 
	      # with this one.
	    next if (!$nokanj and !$restrtxt);

	      # bld_rdngs() guarantees that {_NOKANJI} and {_RESTR} won't
	      # both be present on the same rdng.

	    if (!$nokanj) { 
		  # Put the restr strings into a hash for easy
		  # lookup.  We only care about existence so value
		  # of each item set to 1.
		%xmap = map (($_, 1), @$restrtxt);

		  # Do the same with the text from the @$kanj records
		  # if the caller hasn't already done it.
		if (!$kmap) { $kmap = {map (($_->{txt}, $_), @$kanj)}; }

		  # Look for any restr kanji text that is not in the
		  # entry's kanji text.
		@nomatch = grep (!$kmap->{$_}, @$restrtxt);
		if (@nomatch) { 
		    error ("restr value(s) '" . 
			    join ("','", @nomatch) . 
			    "' not in the entry's readings or kanji");
		    $errs++; }

		  # Get a list of the disallowd kanji by finding all the
		  # items in @$kanj that are not in @$restrtxt (which was
		  # hashed into %xmap above).
		@disallowed = grep (!$xmap{$_->{txt}}, @$kanj); }

	    else {
		@disallowed = ();
		if (!$kanj || !@$kanj) {
		    error ("Entry has no kanji but reading has 'nokanji' tag");
		    $errs++; }

		  # If this reading was marked "nokanji", then all 
		  # the entries kanji are disallowed.
		else { @disallowed = @$kanj; } }

	      # Use the list of disallowed kanji to create the restr 
	      # list that is attached to the reading.
	    if (@disallowed) { 
		$r->{lc($listkey)} = [map (+
		  {entr=>$r->{entr}, $rdngkey=>$r->{$rdngkey}, $kanjkey=>$_->{$kanjkey}},
		  @disallowed)]; } }
	return $errs ? undef : 1; }

    sub append { my ($sens, $key, $item) = @_; 

	# Append $item to the list, @{$sens->{$key}}, creating 
	# the latter if needed.

	if (!($sens->{$key})) { $sens->{$key} = []; }
	push (@{$sens->{$key}}, $item); }

    sub gcleanup { my ($txt) = @_;

	# Remove leading and trailing whitespace from string.
	# Unescape escaped ';'s and '['s.

	$txt =~ s/^[\s\x{3000}]+//;
	$txt =~ s/[\s\x{3000}]+$//;
	$txt =~ s/\\([;\[])/$1/g;
	return $txt; }

    sub error { 
	push (@::TmpError, @_); } 

    sub dummy {

	# For debugging.  Delete me soon please. 

	print "dummy: $_[0]\n"; 
	return; }

    sub dbgprt { my ($typ, $msg) = @_;

	# Called at various places in the parser and lexer to
	# show what itis doing.  YAPP also has debugging output
	# but I like mine better.
 
	my ($pre);
	return if (!($typ & $::dbg));
	if ($typ == 1) { $pre = "Applying rule:"; }
	if ($typ == 2) { $pre = "Lexer returning:"; }
	if ($typ == 4) { $pre = "Lexer state:"; }
	# print STDERR "$pre $msg\n";
	$::dbgtxt .= "$pre $msg\n"; } 

    sub _pushlexstate { my ($state) = @_;
	push (@::Lexstate, $state); 
	if ($::dbg & 4) { dbgprt (4, join(",",@::Lexstate)); } }

    sub _poplexstate { 
	if (scalar(@::Lexstate) > 1) { pop (@::Lexstate); }	
	if ($::dbg & 4) { dbgprt (4, join(",",@::Lexstate)); } }

    sub _setlexstate { my ($state) = @_;
	@::Lexstate = ($state); 
	if ($::dbg & 4) { dbgprt (4, join(",",@::Lexstate)); } }

    sub _mklexer { my ($txt) = @_;
	# Create lexer sub as a closure so that it has a copy
	# of the text string ($txt) it is analyzing.
	my $subr = sub { my ($parser) = @_;
	    my ($t, $s);

	    # The lexer has three states, and recognises a different set
	    # of tokens in each state.  The states are:
	    #   0 -- Recognise tokens relevant in the reading and
	    #        kanji sections.
	    #   1 -- Recognise tokens within a taglist enclosed in square
	    #        brackets "[...]".
            #   2 -- Recognise tokens when parsing glosses.
	    # A stack of states in maintained in @::Lexstate and the 
	    # topmost element ($Lexstate[-1]) is the current state.
	    # The parser controls the state stack via the functions
	    # _pushlexstate(), _poplexstate(), and _setlexstate().
	    
	    $s = $::Lexstate[-1]; # dbgprt (4, "=" . $s);

	      # Skip over any whitespace.  \x{3000} is a ja space.

	    $txt =~ m/\G[\s\x{3000}]+/smcg;

	      # YAPP requires (undef,"") to be returned at the end of
	      # the text.  Perl function pos() gives the current position
	      # within the text.

	    return (undef, "") if (pos($txt) >= length ($txt));

	      # All the regex's below start with \G and use the flags
	      # /cg which tell the regex engine to start the match at
	      # the point where the last successful match (which was
	      # probably during the previous call to this function)
	      # left off.

	    if ($s == 0) {	# Inside reading or kanji sections.
		# We only care about characters that delimit 
		# individual kanji or reading items (semicolon)
		# or that signal a change in state (left bracket,
		# or sense number.
		  
		  # Match the sense number pattern explicitly since it
		  # too much lookahead to have the parser detect it
		  # as BRKTL NUMBER BRKTR.
		if ($txt =~ m/\G(\[\d+\])/cg)  { return ("SNUM", $1); }
		if ($txt =~ m/\G[;\x{FF1B}]/cg)  { return ("SEMI", ";"); }
		if ($txt =~ m/\G\[/cg) { return ("BRKTL", "["); }
		  # Match any text up to whitespace or any of the special
		  # character recognised above. 
		if ($txt =~ m/\G([^;\x{FF1B}:=,\[\]\x{3000} \t\r\n]+)/smcg) { 
		      # Classify it as kanji, reading (kana), or ordinary
		      # text and return token accordingly.
		    $t = jmdict::jstr_classify ($1);
		    if ($t & $jmdict::KANJI) { return ("KTEXT", $1); }
		    if ($t & $jmdict::KANA)  { return ("RTEXT", $1); }
		    return ("TEXT", $1); } }

	    elsif ($s == 1) {	# Inside taglist.
		  # Match quoted string allowing for included \", but
		  # not currently \\. 
		if ($txt =~ m/\G"((([^"\\])|(\\"))+)"/cg)  { return ("TEXT", "$1"); }
		  # Match special characters in taglists...
		if ($txt =~ m/\G[:]/cg)  { return ("COLON", ":"); }
		if ($txt =~ m/\G([;\x{FF1B}])/cg)  { return ("SEMI", "$1"); }
		if ($txt =~ m/\G[,]/cg)  { return ("COMMA", ","); }
		if ($txt =~ m/\G[=]/cg)  { return ("EQL", "="); }
		if ($txt =~ m/\G([\/\x{FF0F}])/cg) { return ("SLASH", "$1"); }
		if ($txt =~ m/\G[\[]/cg) { return ("BRKTL", "["); }
		if ($txt =~ m/\G[\]]/cg) { return ("BRKTR", "]"); }
		  # If none of the above, match any sequence of characters
		  # up to the next whitespace of special character.
		if ($txt =~ m/\G([^;\x{FF1B}:=,\/\x{FF0F}\[\] \t\r\n]+)/smcg) { 
		      # Classify it as kanji, reading (kana), or ordinary
		      # text and return token accordingly.
		    $t = jmdict::jstr_classify ($1);
		    if ($t & $jmdict::KANJI) { return ("KTEXT", $1); }
		    if ($t & $jmdict::KANA)  { return ("RTEXT", $1); }
		    return ("TEXT", $1); } }

	    elsif ($s == 2) {	# Inside glosses section.
		  # When parsing glosses the only spacial characters
		  # we care about are ";" which seperates glosses,
		  # "[" which starts a taglist, and "[\d+]" which denotes
		  # a new sense.  We don't treat whitespace specially
		  # (it is preserved and included in the token's value.)
		if ($txt =~ m/\G(\[\d+\])/cg)   { return ("SNUM", $1); }
		  # Following regex allows "[" and ";" in the gloss text 
		  # if escaped with a "\" character. 
		if ($txt =~ m/\G((([^;\\\[])|(\\\[)|(\\;))+)/cg) { return ("GTEXT", $1); }
		if ($txt =~ m/\G;/cg) { return ("SEMI", ";"); } 
		if ($txt =~ m/\G\[/cg) { return ("BRKTL", "["); } }

	    else { die "Invalid lexer state '$s' encountered\n"; }

	      # A catch all.  The parser does not use OTHER token in any
	      # productions so it will cause the parser to generate a 
	      # a parse error.
	    ($txt =~ m/\G(.)/smcg) && return ("OTHER", $1); 
	    die "How the heck did this happen?\n"; }; 
	return $subr; }

    sub _error { my ($parser) = @_;
	# This function is called by the YAPP parser when it 
	# detects parse error.  We create and save an error
	# message describing the error.
	# 
	# Parse errors may be generated by a YAPP detected
	# syntax error in the input, or syntheised by our 
	# when semantic value code when some non-purely
	# syntactic error is found.  In that latter case
	# the error detecting code will put error message
	# in global variable @::tmpError, and we retrieve 
	# it from there and use it as the error message.
	#
	# When a syntax error is detected by the YAPP parse
	# engine, we synthesise an error message from the
	# info the YAPP makes available.
	
	my ($msg, $wanted, @expected);
	  # Get the error message saved by our seantic code
	  # (if any).
	$msg = join ("\n", @::TmpError);

	if ($msg) {
	      # Clear the transfer variable for the next time.
	    @::TmpError = (); }
	else { 
	      # If there was no message then this is a syntax
	      # error that YAPP detected.  We will synthesise
	      # a message.
	    @expected = $parser->YYExpect();
	    if (0 == scalar (@expected)) { $wanted = "<EOF>"; }
	    elsif (1 == scalar (@expected)) { $wanted = "'$expected[0]'"}
	    else { $wanted = "one of '" . join ("', '", @expected) . "'" }
	    $msg = "parse error: read a ". $parser->YYCurtok() ." token, expected $wanted"; }
	# $msg .= " at line $.";

	  # Save the message is a message stack that will be
	  # printed by the main program after the parser is 
	  # finished.
	push (@::Errors, $msg); }
	
    sub parse_text { my ($self, $txt, $dbg) = @_;
	my ($parser, $lexer, $result, $dbglexer);
	$parser = new ("jbparser");
	$::dbg = $dbg;
	@::Errors = ();
	$lexer = _mklexer ($txt); 
	$dbglexer = 
	    sub { my ($p) = @_; 
		my ($t, $v) = &$lexer ($p);
		if ($::dbg & 2) { dbgprt (2, "token='$t', val='$v'"); }
		return ($t, $v); };
	@::Lexstate = (0);
	$result = $parser->YYParse (yylex=>$dbglexer, yyerror=>\&_error);
	($result, \@::Errors); }

    1;
