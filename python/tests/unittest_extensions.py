from __future__ import print_function, absolute_import, division
from future_builtins import ascii, filter, hex, map, oct, zip 
import sys, os, os.path, unittest, time, subprocess, tempfile, \
       shutil, difflib, re, pdb

class TextTestRunner (unittest.TextTestRunner):
    """
	A TextTestRunner provides a run method that will run a 
	test suite and write formatted results to a stream.  We 
	subclass the unittest TextTestRunner and provide better
	output and formmating contro than that one does.

	Arguments given when TextTestRunner is instantiated control
	how the test results are formatted and displayed. 
	When a suite is run by .run(), three kinds of result data
	are produced:

	1. Progress information generated by each test when it is run.
	2. For tests that fail or error, the detailed error information.
	3. Summary information for the suite results.  

	The format of (1) is controlled by 'verbosity'.  (3) may be 
	turned off or on with 'summary'.  (1) and (3) are always 
	written to 'stream', (2) is written there too by default but
	may optionally be written elsewhere with 'dstream'.
    """

    def __init__(self, stream=sys.stderr, descriptions=True, verbosity=1,
		       summary=True, dstream=None):
	"""
	Parameters: 

	    stream -- (file) 
		File to write test progress information to.  Default is
		sys.stderr.
	    descriptions -- (boolean)
		If true, identity tests by description if available.  If 
		not true, or description not available, use tests class 
		and method name.
	    verbosity -- (int)
		Control display of test progress display
		0 -- No progress output.
		1 -- As each test is executed, print successive ".", "F", 
		  or "E" charcters on a line for sucessful, failed, or 
		  errored tests respectively. Output is written to 'stream'.
	    summary -- (boolean)
		Print a summary line (to 'stream') after full test suite 
		has been executed, giving the number of successful tests,
		failed tests, errored tests, and time taken.
	    dstream -- (file)
		File to write error details of failing or erroring tests
		to.  If not given or None, 'stream' will be used.
	Returns:
	    A unittest._TextTestResult object that contains all the
	    test results for the suite.
	"""

	unittest.TextTestRunner.__init__ (self, stream, descriptions, verbosity)
	if not dstream: self.dstream = self.stream
	else: self.dstream = unittest._WritelnDecorator(dstream)
	self.summary = summary

    def run(self, test):
        result = self._makeResult()
	if self.verbosity > 1: 
	    self.stream.writeln()
	suite_name = getattr (test, 'name', '')
	if suite_name: suite_name += ": "
	if suite_name:
	    if self.verbosity > 0: 
		self.stream.write (suite_name)
	    if self.verbosity > 1: 
		self.stream.writeln()

        startTime = time.time()
        test (result)
        timeTaken = time.time() - startTime
        failed, errored = map(len, (result.failures, result.errors))
        total = result.testsRun

	if self.verbosity == 1 and not (self.stream == self.dstream \
		and (failed or errored)) : self.stream.writeln()

        if failed or errored and self.dstream: 
	    result.stream = self.dstream
	    result.printErrors()
	    result.stream = self.stream

	if self.summary:
	    name = suite_name[:-2] + ' '
	    maxerr = "ERROR" if errored else "FAIL" if failed else "OK"
	    summary = "%s%s: %d ok, %d fails, %d errors, %d total in %.3fs" \
	               % (name, maxerr, total - (failed + errored),
			 failed, errored, total, timeTaken)
	    self.stream.writeln (summary)
        return result

# In Python-2.5, Exception cannot be used with unicode arguments
# because the Exception default __str__() method calls str() which 
# results in a UnicodeEncodeError since the default encoding is almost
# always ascii, which in turn results in the exception message, 
# "Unprintable exception".  See http://bugs.python.org/issue2517
#
# We define our own flavor of exeception that will do it's own
# encoding. 

class EncodedAssertionError (AssertionError):
    def __init__ (self, *args, **kwds):
	AssertionError.__init__ (self, *args, **kwds)
	self.encoding = sys.stdout.encoding or 'utf-8'
    def __str__ (self):
	try: 
	   return self.args[0].encode(self.encoding)
	except: return AssertionError.__str__(self)

# Tell the unicode module to use it.
unittest.TestCase.failureException = EncodedAssertionError


def runcmd (wkdir, cmdln):
	proc = subprocess.Popen (cmdln, shell=True, cwd=wkdir, 
		    env=os.environ,
		    stdout=subprocess.PIPE, stderr=subprocess.PIPE)
	rc = proc.wait()
	stdout, stderr = proc.communicate()
	if rc != 0: raise RuntimeError (stderr)
	return stdout, stderr

def readfile_utf8 (fname, enc='utf-8', secsep=None, rmcomments=False):
	# Read file named 'fname' and return its contents as either a
	# string (if 'secsep' is None), or, (if 'secsep' is not None)
	# a dict of strings, where each dict key is a section label,
	# and each value, a text a string for that section on the file.
	# A line in the file that matches regex pattern 'secsep' separates
	# sections.  If 'secsep' has a subgroup, it will be used for the
	# label.  Otherwise, the section number (starting at 0) will be
	# used for the label.
	# If 'rmcomments' is true, comment and blank lines not be 
	# included in the output text strings.

	results = {}; current_txts = []; secnum = 0; label=0
	def save (results, label, current_txts):
	    if label in results: raise ValueError ("Duplicate test '%s'" % label)
	    ln = ''.join (current_txts)
	    results[label] = ln
	    return [], secnum + 1
 
	with open (fname) as f:
	    for lnnum, ln in enumerate (f):
		ln = ln.decode (enc)
	        if lnnum == 0 and ln[0] == u'\uFEFF': ln = ln[1:]
		mo = re.match (secsep, ln) if secsep else None
		if mo:
		    if current_txts:
		        current_txts, secnum = save (results, label, current_txts)
		    try: label = mo.group(1)
		    except StandardError: label = secnum
		    continue
		  # Note that blank lines are NOT comments.
	        if rmcomments and re.match (r'\s*#', ln): continue
		current_txts.append (ln)
	save (results, label, current_txts)
	if secsep is None: return results[0]
 	return results

def mk_temp_dir (in_dir=".", keep=False):
	dirname = tempfile.mkdtemp ("tmp", dir=in_dir)
	if not keep: atexit.register (rm_temp_dir, dirname)
	return dirname

def rm_temp_dir (dirname):
	if sys.platform == 'win32': dirname = unicode(dirname)
	else: dirname = dirname.encode(sys.getfilesystemencoding())
	print ("Removing", dirname)
	shutil.rmtree (dirname)

def diff_strings (a, b):
        """Return ndiff between two strings containing lines.
        A trailing newline is added if missing to make the strings
        print properly."""

        if b and b[-1] != '\n': b += '\n'
        if a and a[-1] != '\n': a += '\n'
        #difflines = difflib.ndiff(a.splitlines(True), b.splitlines(True),
        #                          linejunk=lambda x: False, charjunk=lambda x: False)
        difflines = difflib.unified_diff(a.splitlines(True), b.splitlines(True), n=0)
        return ''.join(difflines)

def match (pat, a):
	mo = re.search (pat, a)
	return True if mo else False
