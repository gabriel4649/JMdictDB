#!/usr/bin/env python
#######################################################################
#  This file is part of JMdictDB. 
#  Copyright (c) 2007,2008 Stuart McGraw 
# 
#  JMdictDB is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published 
#  by the Free Software Foundation; either version 2 of the License, 
#  or (at your option) any later version.
# 
#  JMdictDB is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
# 
#  You should have received a copy of the GNU General Public License
#  along with JMdictDB; if not, write to the Free Software Foundation,
#  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA
#######################################################################
#
# Generate a static keywords module from database kw tables or csv files.
#
__version__ = ("$Revision$"[11:-2],
	       "$Date$"[7:-11])

import sys, os, inspect, pdb
_ = os.path.abspath(os.path.split(inspect.getfile(inspect.currentframe()))[0])
_ = os.path.join (os.path.dirname(_), 'python', 'lib')
if _ not in sys.path: sys.path.insert(0, _) 

import re, datetime
import jdb

def main (args, opts):
	KW = jdb.Kwds ()
	if opts.database:
	    cur = jdb.dbOpen (opts.database, **jdb.dbopts (opts))
	    KW.loaddb (cur)
	for dir in args:
	    KW.loadcsv (dir)
	gen_module (KW)

def gen_module (KW):
	print "# This file was generated by mkkwmod.py on %s" \
	       % (datetime.datetime.today().ctime())
	print "\nimport jdb\n"
	print "KW = jdb.Kwds()"
	for t in KW.attrs():
	    for r in KW.recs (t):
		print "KW.add (\"%s\", (%d, r'%s', %s))" % (t, r[0], r[1], repr(r[2]))
	print 
	for t in KW.attrs():
	    for r in KW.recs (t):
		w = "KW" + t + "_" + r.kw
		w = w.replace("-", "_")
		print "%s = %s" % (w, r.id)

def parse_cmdline ():
	from optparse import OptionParser, OptionGroup
	u = \
"""\n\tpython %prog [options] [cvs-directory [cvs-directory [...]]]
	
  %prog will write a Python module (to stdout) which when imported,
  will create the same data structures as are created by the jdb.KWDS
  class.  The module produced by this program is typically imported
  by programs that need access to jdb keyword values but don't other-
  wise need or want to access a database to get them.

  The kw data to be written may come from a jmdictdb database (if the
  --database option is given) and/or from csv files (if any csv-directory
  arguments are given).  When multiple sources are provided, the database 
  keywords are loaded first, then the csv files in csv-directory argument
  order.  If the same id or kw values are specified in mutiple sources,
  the later processed ones will overwrite the earlier. 

Arguments: 
	csv-directory -- Path to directory containg csv files."""

	v = "Version %s (%s)" % __version__
	p = OptionParser (usage=u, version=v, add_help_option=False)

	p.add_option ("--help",
            action="help", help="Print this help message.")

	g = OptionGroup (p, "Database access options",
		"""Caution: On many systems, command line option contents
		may be visible to other users on the system.  For that 
		reason, you should avoid using the "--user" and "--password"
		options below and use a .pgpass file (see the Postgresql
		docs) instead. """)
	g.add_option ("-d", "--database", default=None,
            help="Name of the database to load.")
	g.add_option ("-h", "--host", default=None,
            help="Name or ip address of machine database resides on.")
	g.add_option ("-u", "--user", default=None,
            help="Connect to database with this username.")
	g.add_option ("-p", "--password", default=None,
            help="Connect to database with this password.")
	p.add_option_group (g)

	opts, args = p.parse_args ()
	return args, opts

if __name__ == '__main__': 
	args, opts = parse_cmdline ()
	sys.argv[0] = sys.argv[0].split('\\')[-1].split('/')[-1]
	main (args, opts)
